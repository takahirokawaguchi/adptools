;(load "~/git/work/sta/source/dat-functions.ils")
;;;=======
;;;Utility
;;;=======
(defun inputTermsConnected (pinOrOutputTerm)
  (if (geqp (length (setof x pinOrOutputTerm~>net~>instTerms (isInputTerm x))) 2)
    (cond 
      ((member (ptlType pinOrOutputTerm~>inst)
               (list "PTL2" "viar"))
       (setof x pinOrOutputTerm~>net~>instTerms
              (and
                (isInputTerm x)
                (member (ptlType x~>inst)
                        (list "PTL2" "via")))))
      ((member (ptlType pinOrOutputTerm~>inst)
               (list "PTL1" "via"))
       (setof x pinOrOutputTerm~>net~>instTerms
              (and
                (isInputTerm x)
                (member (ptlType x~>inst)
                        (list "PTL1" "viar")))))
      (t
        (progn
          (warn "%s_%s is connected to more than one inputTerms"
                pinOrOutputTerm~>inst~>name pinOrOutputTerm~>name)
          (setof x pinOrOutputTerm~>net~>instTerms (isInputTerm x))
          ))));cond if
  (setof x pinOrOutputTerm~>net~>instTerms (isInputTerm x)))
(defun outputTermsConnected (pinOrInputTerm)
  (setof x pinOrInputTerm~>net~>instTerms (isOutputTerm x))) 

(defun ptlType (inst)
  (cond
    ((rexMatchp "^PTL1" inst~>cellName)
     "PTL1")
    ((or
       (rexMatchp "^PTL2" inst~>cellName)
       (rexMatchp "^drv" inst~>cellName)
       (rexMatchp "^rec" inst~>cellName))
     "PTL2")
    ((rexMatchp "^via[a-z]*r$" inst~>cellName)
     "viar")
    ((rexMatchp "^via[a-z]*" inst~>cellName)
     "via")))
(defun isClocked (inst) (setof x inst~>instTerms x~>name == "clk"))
(defun isIpin (inst) inst~>cellName == "ipin")
(defun isOpin (inst) inst~>cellName == "opin")
(defun isIopin (inst) inst~>cellName == "iopin")
(defun isJTL (inst)
  (and (null (isRoutingCell inst))
       (rexMatchp "^jtl" inst~>cellName)))
(defun isSPLJTLX (inst) 
  (or (rexMatchp "^spl.jtl" inst~>cellName)
      (rexMatchp "^spl[a-zA-Z].*jtl" inst~>cellName)))
(defun isSPL (inst)
  (or (isPspl inst)
      (rexMatchp "^spl" inst~>cellName)))
(defun isSPL3JTLX (inst) (rexMatchp "^spl3.jtl" inst~>cellName))
(defun isCB (inst)
  (and (null (isCBJTLX inst))
       (rexMatchp "^cb" inst~>cellName)))
(defun isKand (inst)
  (rexMatchp "^kand*" inst~>cellName))
(defun isKnimply (inst)
  (rexMatchp "^knimply*" inst~>cellName))
(defun isCBJTLX (inst) (rexMatchp "^cb.jtl" inst~>cellName))
(defun isRoutingCell (inst) 
  (length (setof x inst~>instTerms (isInputTerm x))) == 1)
(defun isPTLFamily (inst) 
  (or
    (isPTL inst)
    (isPTLRec inst)
    ))
(defun isPTLDrvRec (inst) 
  (or
    ;(isPTL inst)
    (isPTLRec inst)
    (isPTLDrv inst)
    (isPspl inst)
    ))
(defun isPTL (inst)
  (or
    (rexMatchp "^PTL" inst~>cellName)
    (rexMatchp "^via" inst~>cellName)
    ))
(defun isPTLRec (inst) 
  (rexMatchp "^rec" inst~>cellName))
(defun isPTLDrv (inst) 
  (rexMatchp "^drv" inst~>cellName))
(defun isPspl (inst) 
  (rexMatchp "^pspl" inst~>cellName))
(defun isSource (inst) (rexMatchp "^source" inst~>cellName))
(defun isT1 (inst) (rexMatchp "^t1" inst~>cellName))
(defun isD2ff (inst) (rexMatchp "^d2ff" inst~>cellName))
(defun isRdff (inst)
  (or (rexMatchp "^rdff" inst~>cellName)
      (rexMatchp "^d3ff" inst~>cellName)))
(defun isRtff (inst) (rexMatchp "^rtff" inst~>cellName))
(defun isDffe (inst) (rexMatchp "^dffe" inst~>cellName))
(defun isDff (inst)
  (and (null (isDffe inst))
       (rexMatchp "^dff" inst~>cellName)))
(defun isNdroc (inst) (rexMatchp "^ndroc" inst~>cellName))
(defun isNdro (inst)
  (and (null (isNdroc inst))
       (or
         (rexMatchp "^ndro" inst~>cellName)
         (rexMatchp "^nrdo" inst~>cellName))
       ))
(defun isTff (inst) (rexMatchp "^tff" inst~>cellName))
(defun isJnote (inst) (rexMatchp "^jnote" inst~>cellName))
(defun isJnot (inst)
  (and (null (isJnote inst))
       (rexMatchp "^jnot" inst~>cellName)))
(defun isJande (inst) (rexMatchp "^jande" inst~>cellName))
(defun isJandf (inst) (rexMatchp "^jandf" inst~>cellName))
(defun isJand (inst)
  (and (null (isJande inst))
       (null (isJandf inst))
       (rexMatchp "^jand" inst~>cellName)))
(defun isJnand (inst) (rexMatchp "^jnand" inst~>cellName))
(defun isJor (inst) (rexMatchp "^jor" inst~>cellName))
(defun isJnor (inst) (rexMatchp "^jnor" inst~>cellName))
(defun isJxore (inst) (rexMatchp "^jxore" inst~>cellName))
(defun isJxor (inst)
  (and (null (isJxore inst))
       (rexMatchp "^jxor" inst~>cellName)))
(defun isRjxor (inst) (rexMatchp "^rjxor" inst~>cellName))
;(defun is2x2join (inst) (rexMatchp "^join2x2" inst~>cellName))
;(defun isBina (inst) (rexMatchp "^Bina" inst~>cellName))
;(defun isTBina (inst) (rexMatchp "^tBina" inst~>cellName))
;(defun isMullerc (inst) (rexMatchp "^mullerc" inst~>cellName))
;(defun is (inst) (rexMatchp "^" inst~>cellName))

(defun hasMaxTimingConstraint (inst)
  (or (isCB inst)
      (isKand inst)
      (isKnimply inst)))


(defun inputTerms (inst) (setof x inst~>instTerms (isInputTerm x)))
(defun outputTerms (inst) (setof x inst~>instTerms (isOutputTerm x)))

(defun isInputTerm (instTerm) instTerm~>direction == "input")
(defun isOutputTerm (instTerm) instTerm~>direction == "output")
(defun pinsConnected (instTerm) (car instTerm~>net~>pins~>figs))


(defun exchangeDinDout (string)
  (cond
    ((equal (strncmp string "din" 3) 0)
     (setq x (strcat "dout" (substring string 4))))
    ((equal (strncmp string "dout" 4) 0)
     (strcat "din" (substring string 5)))
    ))
(defun exchangeClkOut (string)
  (cond
    ((equal (strncmp string "clk" 3) 0)
     (setq x (strcat "out" (substring string 4))))
    ((equal (strncmp string "out" 3) 0)
     (strcat "clk" (substring string 4)))
    ))

(defun andList (xs)
  (if (cdr xs)
    (and (car xs)
         (andList (cdr xs)))
    (car xs)))
(defun orList (xs)
  (if (cdr xs)
    (or (car xs)
        (orList (cdr xs)))
    (car xs)))
(defun minList (xs)
  (if (cdr xs)
    (min  (car xs) (minList (cdr xs)))
    (car xs)))
(defun maxList (xs)
  (if (cdr xs)
    (max  (car xs) (maxList (cdr xs)))
    (car xs)))
(defun appendList (xs)
  (if (cdr xs)
    (append (car xs) (appendList (cdr xs)))
    (car xs)))
(defun plusList (xs)
  (if (cdr xs)
    (plus (car xs) (plusList (cdr xs)))
    (car xs)))

(defun intersection (list1 list2 )
  (setof element list1
         (member element list2 ))) 
(defun replaceAssoc (assocList key value)
  (rplaca (cdr (assoc key assocList)) value))
;(defun replaceList (aList value newValue)
;  (rplaca (member value aList) newValue))
(defun replaceListNth (aList number newValue)
  (when (geqp (length aList)
              number)
    (rplaca (nthcdr number aList) newValue)))
