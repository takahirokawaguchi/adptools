(defun ptlType (inst)
  (cond
    ((rexMatchp "^PTL1" inst~>cellName)
     "PTL1")
    ((or
       (rexMatchp "^PTL2" inst~>cellName)
       (rexMatchp "^drv" inst~>cellName)
       (rexMatchp "^rec" inst~>cellName))
     "PTL2")
    ((rexMatchp "^via[a-z]*r$" inst~>cellName)
     "viar")
    ((rexMatchp "^via[a-z]*" inst~>cellName)
     "via")))

(defun isClocked (inst) (setof x inst~>instTerms x~>name == "clk"))
(defun isIpin (inst) inst~>cellName == "ipin")
(defun isOpin (inst) inst~>cellName == "opin")
(defun isIopin (inst) inst~>cellName == "iopin")

(defun isJTL (inst)
  (and (null (isRoutingCell inst))
       (rexMatchp "^jtl" inst~>cellName)))
(defun isSPL (inst)
  (or (isPspl inst)
      (rexMatchp "^spl" inst~>cellName)))

(defun isSPLJTLX (inst) 
  (or (rexMatchp "^spl.jtl" inst~>cellName)
      (rexMatchp "^spl[a-zA-Z].*jtl" inst~>cellName)))
(defun isSPL3JTLX (inst) (rexMatchp "^spl3.jtl" inst~>cellName))

(defun isCB (inst)
  (and (null (isCBJTLX inst))
       (rexMatchp "^cb" inst~>cellName)))
(defun isCBJTLX (inst) (rexMatchp "^cb.jtl" inst~>cellName))

(defun isKand (inst)
  (rexMatchp "^kand*" inst~>cellName))
(defun isKnimply (inst)
  (rexMatchp "^knimply*" inst~>cellName))

(defun isRoutingCell (inst) 
  (length (setof x inst~>instTerms (isInputTerm x))) == 1)
(defun isPTLFamily (inst) 
  (or
    (isPTL inst)
    (isPTLRec inst)
    ))
(defun isPTLDrvRec (inst) 
  (or
    ;(isPTL inst)
    (isPTLRec inst)
    (isPTLDrv inst)
    (isPspl inst)
    ))
(defun isPTL (inst)
  (or
    (rexMatchp "^PTL" inst~>cellName)
    (rexMatchp "^via" inst~>cellName)
    ))
(defun isPTLRec (inst) 
  (rexMatchp "^rec" inst~>cellName))
(defun isPTLDrv (inst) 
  (rexMatchp "^drv" inst~>cellName))
(defun isPspl (inst) 
  (rexMatchp "^pspl" inst~>cellName))

(defun isSource (inst) (rexMatchp "^source" inst~>cellName))

(defun isT1 (inst) (rexMatchp "^t1" inst~>cellName))
(defun isD2ff (inst) (rexMatchp "^d2ff" inst~>cellName))
(defun isRdff (inst)
  (or (rexMatchp "^rdff" inst~>cellName)
      (rexMatchp "^d3ff" inst~>cellName)))
(defun isRtff (inst) (rexMatchp "^rtff" inst~>cellName))
(defun isDffe (inst) (rexMatchp "^dffe" inst~>cellName))
(defun isDff (inst)
  (and (null (isDffe inst))
       (rexMatchp "^dff" inst~>cellName)))
(defun isNdroc (inst) (rexMatchp "^ndroc" inst~>cellName))
(defun isNdro (inst)
  (and (null (isNdroc inst))
       (or
         (rexMatchp "^ndro" inst~>cellName)
         (rexMatchp "^nrdo" inst~>cellName))
       ))
(defun isTff (inst) (rexMatchp "^tff" inst~>cellName))
(defun isJnote (inst) (rexMatchp "^jnote" inst~>cellName))
(defun isJnot (inst)
  (and (null (isJnote inst))
       (rexMatchp "^jnot" inst~>cellName)))
(defun isJande (inst) (rexMatchp "^jande" inst~>cellName))
(defun isJandf (inst) (rexMatchp "^jandf" inst~>cellName))
(defun isJand (inst)
  (and (null (isJande inst))
       (null (isJandf inst))
       (rexMatchp "^jand" inst~>cellName)))
(defun isJnand (inst) (rexMatchp "^jnand" inst~>cellName))
(defun isJor (inst) (rexMatchp "^jor" inst~>cellName))
(defun isJnor (inst) (rexMatchp "^jnor" inst~>cellName))
(defun isJxore (inst) (rexMatchp "^jxore" inst~>cellName))
(defun isJxor (inst)
  (and (null (isJxore inst))
       (rexMatchp "^jxor" inst~>cellName)))
(defun isRjxor (inst) (rexMatchp "^rjxor" inst~>cellName))
;(defun is2x2join (inst) (rexMatchp "^join2x2" inst~>cellName))
;(defun isBina (inst) (rexMatchp "^Bina" inst~>cellName))
;(defun isTBina (inst) (rexMatchp "^tBina" inst~>cellName))
;(defun isMullerc (inst) (rexMatchp "^mullerc" inst~>cellName))
;(defun is (inst) (rexMatchp "^" inst~>cellName))

(defun hasMaxTimingConstraint (inst)
  (or (isCB inst)
      (isKand inst)
      (isKnimply inst)))

(defun inputTerms (inst) (setof x inst~>instTerms (isInputTerm x)))
(defun outputTerms (inst) (setof x inst~>instTerms (isOutputTerm x)))

(defun isInputTerm (instTerm) instTerm~>direction == "input")
(defun isOutputTerm (instTerm) instTerm~>direction == "output")

(defun pinsConnected (instTerm) (car instTerm~>net~>pins~>figs))

